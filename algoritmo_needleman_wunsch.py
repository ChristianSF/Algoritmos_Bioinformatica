# -*- coding: utf-8 -*-
"""Algoritmo_NeedlemanWunsch

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rN1Duby3cKwanFzYh1gS_1NCoV-JLMjK
"""

delta = lambda x,y,i,j: 1 if x[i] != y[j] else 0

def encontra_solucao(OPT, m, n):
    if m == 0 or n == 0:
      return

    insert = OPT[m][n-1] + 1
    align = OPT[m-1][n-1] + delta(x, y, m-1, n-1)
    delete = OPT[m-1][n] + 1

    melhor_escolha = min(insert, align, delete)

    if melhor_escolha == insert:
      solucao.append('inserir_'+str(y[n-1]))
      return encontra_solucao(OPT[:m+1][:n], m, n-1)

    elif melhor_escolha == align:
      solucao.append('alinhar_' + str(y[n-1]))
      return encontra_solucao(OPT[:m][:n], m-1, n-1)

    elif melhor_escolha == delete:
      solucao.append('remover_'+str(x[m-1]))
      return encontra_solucao(OPT[:m][:n+1], m-1, n)

def alinhamento(x,y):
  n = len(y)
  m = len(x)

  OPT = [ [0 for i in range(n+1)] for j in range(m+1)]

  for i in range(1, m+1):
    OPT[i][0] = i
  
  for j in range(1, n+1):
    OPT[0][j] = j

    for i in range(1, m+1):
      for j in range(1, n+1):
        OPT[i][j] = min(OPT[i-1][j-1] + delta(x,y, i-1, j-1), OPT[i-1][j] + 1, OPT[i][j-1] + 1)
          
  encontra_solucao(OPT, len(x), len(y))
  return OPT[m][n], solucao[::-1]

if __name__ == '__main__':
  solucao = []
  #x = 'TGACGTGC'
  #y = 'TCGACGTCA'

  x = str(input("Digite a primeira sequência: "))
  y = str(input("Digite a segunda sequência: "))
  #alinhamento(x,y)
  print("Queremos transformar: " + x + " em: " + y)
  opt_edit, solucao = alinhamento(x, y)

  print("\n --- Solução --- ")
  print("Minimo de passos necessários para editar são: "+ str(opt_edit))
  print("Caminho para fazer isso: " +str(solucao))

